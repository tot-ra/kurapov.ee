<!DOCTYPE html>
<html lang="en" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="noindex, nofollow">
<title>Artjom Kurapov blog</title>
<meta name="keywords" content="">
<meta name="description" content="понедельник, 21 сентября 2009 г. в 17:02:46
Тестирование софта это процесс, участвующий во всех жизненных циклах его разработки, который занимается проверкой и планированием требований продукта, подготовкой и проведением изменений в разрабатываемой системе. Как следствие — находятся несоответсвия требованиям и ошибки, оцениваются инструменты которые были использованы.
А если отвлечься и рассматривать системно, то роль тестера на самом деле лежит в каждом человеке. Если смотреть на проект как на человека, то роли">
<meta name="author" content="">
<link rel="canonical" href="http://localhost:1313/rus/testing/%D0%BE-%D1%82%D0%B5%D1%81%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B8-web-%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D0%B9-iti0120/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css" integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://localhost:1313/apple-touch-icon.png">
<link rel="mask-icon" href="http://localhost:1313/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="http://localhost:1313/rus/testing/%D0%BE-%D1%82%D0%B5%D1%81%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B8-web-%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D0%B9-iti0120/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="Artjom Kurapov blog (Alt + H)">Artjom Kurapov blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/rus/gaming/" title="Игры">
                    <span>Игры</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/rus/movies/" title="Кино">
                    <span>Кино</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/rus/about/%D0%BE%D0%B1-%D0%B0%D0%B2%D1%82%D0%BE%D1%80%D0%B5/" title="Об авторе">
                    <span>Об авторе</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/rus/tech/" title="Технологии">
                    <span>Технологии</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      
    </h1>
    <div class="post-meta">

</div>
  </header> 
  <div class="post-content"><p>понедельник, 21 сентября 2009 г. в 17:02:46</p>
<p>Тестирование софта это процесс, участвующий во всех жизненных циклах его разработки, который занимается проверкой и планированием требований продукта, подготовкой и проведением изменений в разрабатываемой системе. Как следствие — находятся несоответсвия требованиям и ошибки, оцениваются инструменты которые были использованы.</p>
<p>А если отвлечься и рассматривать системно, то роль тестера на самом деле лежит в каждом человеке. Если смотреть на проект как на человека, то роли</p>
<ul>
<li>управляющего проектом это позвоночник и вегетативная нервная система</li>
<li>программисты это скелет и моторика</li>
<li>аналитики это органы чувств</li>
<li>тестеры это совесть</li>
</ul>
<p>Quality Assurance часто считается синонимом тестирования, но на самом деле это методика предотвращения ошибок, а не их поиска и исправления. Качество в этом смысле - характеристика сделанного продукта.</p>
<p><img loading="lazy" src="img/dilbert2.png" alt=""  />
</p>
<p>Формально говоря, тестер должен проверять даже т_ехническое задание, план проекта и анализ_ на логичность и понятность, а не только код и интерфейс программы. Тестирование как независимая дисциплина в общем потоке разработки ПО появилась в начале девяностых, когда стали более важны аудитория (клиенты), качество и время разработки.</p>
<p>Важность тестирования ПО особенно важна в критических системах. К примеру аппарат по лучевой терапии <a href="http://ru.wikipedia.org/wiki/Therac-25">Therac</a> (1985) облучил смертельной дозой радиации 6 человек из-за отсутсвия проверки состояния агрегата в коде и валидации. Или марсоход в 1999 году принёс убыток в 125 млн долларов из-за непродуманности единой системы измерения между коммандами разработчиков. И даже в Эстонии при электронных выборах были проблемы из-за плохого_нагрузочного тестирования_.</p>
<p>Основные принципы тестирования воплощены в небольшом документе <a href="http://www.istqb.org/">ISTQB</a> и в книге «Foundations of software testing». Вся «прелесть» специальности тестера в том что как правило для этого не нужны большие познания в программировании и люди далёкие от web-строительства могут себя попробовать в этой роли, впрочем в смежных с IT системах без хорошооплачиваемого тестирования не обойтись (автомобилестроение, военные технологии). Тестированию посвящены даже некоторые журналы, например <a href="http://www.testmagazine.co.uk/">TEST Magazine</a>.</p>
<hr>
<h3 id="7-принципов-тестирования">7 принципов тестирования<a hidden class="anchor" aria-hidden="true" href="#7-принципов-тестирования">#</a></h3>
<ol>
<li>Тестирование показывает наличие дефектов, но не доказывает их полное отсутсвие</li>
<li>Полное (exhaustive) тестирование невозможно. Перебрать все комбинации ко входам можно только в тривиальніх случаях. Надо фокусироваться на приоритетах</li>
<li>Начинать тестирование надо на как можно ранних этапах цикла разработки</li>
<li>Ошибки физически образуют кластеры (наиболее ошибочны конкретные модули)</li>
<li>Парадокс пестицидов - ошибки подстраиваются под существующие тесты, поэтому их надо периодически обновлять</li>
<li>Тестирование зависит от контекста системы</li>
<li>Отсутствие дефектов не значит выполнение требований и ожиданий пользователя</li>
</ol>
<h3 id="организационный-процесс">Организационный процесс<a hidden class="anchor" aria-hidden="true" href="#организационный-процесс">#</a></h3>
<p>Тестирование как часть работы компании над проектом может проходить либо в waterfall-подходе, где под тестер подтягивается лишь под конец проекта, либо по agile-методологии, где с каждой итерацией выкатывается готовая версия.</p>
<p><img loading="lazy" src="img/iteration_12_4-717751.jpg" alt=""  />
</p>
<p>Итерация тестирования состоит из следующих пунктов</p>
<ol>
<li>
<p>Планирования. Определяются цели, инструменты, время, порядок. Самая психологически сложная часть - понять и запомнить как система _должна_работать, особенно когда нет технического задания, документации и вменяемого управляющего проектом (см. <em>exploratory testing</em> ниже)</p>
<p>Посему у тестера хотя-бы внутренний, но анализ состоит из..</p>
<ul>
<li>Условий (conditions)</li>
<li>Истории взаимодействий (cases</li>
<li>Воплощение в виде документа (basis) со ссылками на спецификацию, архитектуру и прочие документы (коли они есть)</li>
</ul>
</li>
<li>
<p>Проверки. В случае недоступностей и непонятностей - когда и с кем связаться что-бы задание не забылось.</p>
<ul>
<li>Приоритезация тест-case&rsquo;ов (обычно 1 case = 1 требование = 1 web-страница). Какие сценарии самые критичные? Какие в разработке и наиболее рискованные?</li>
<li>Группировка тестов в комплекты (suite) по общим модулям</li>
<li>Проверка и сравнение с требованиями (собственно поиск ошибок)</li>
<li>Написание рапорта (как багов, так и общей картины - процент покрытия)</li>
<li>Перепроверка изменённой части (confirmation, retesting) или влияния на неизменённые части (<em>regression testing</em>)</li>
</ul>
</li>
<li>
<p>Завершение. Архивация тестов, сохранение полученных уроков.</p>
</li>
</ol>
<p><img loading="lazy" src="img/dilbert-minivan.gif" alt=""  />
</p>
<h3 id="тестирование-спецификации">Тестирование спецификации<a hidden class="anchor" aria-hidden="true" href="#тестирование-спецификации">#</a></h3>
<p>Мне как программисту приходится, к несчастью, постоянно сталкиваться с неправильно сформулированными заданиями. Аналитикам составляют стоит обратить внимание на следующие пункты</p>
<ol>
<li>
<p>Многозначность - общая и самая главная проблема. Задание недостаточно чётко описано.</p>
</li>
<li>
<p>Неопределённые термины (очень, много, часто..)</p>
</li>
<li>
<p>Обобщение (все, всегда). Как часто бывает в программировании - злоупотребление глобальными переменными вредно, ограничивает и вводит конфликты в спецификации</p>
</li>
<li>
<p>Специфичные термины без ссылки на их описание</p>
</li>
<li>
<p>Уровень обобщённости (все,многие,некоторые) - глагол говорит обо всех или об одном?</p>
</li>
<li>
<p>Критические слова (только, тоже, особенно) сильно ограничивают глобальные права и часто с ними противоречат (например - <em>анонимные пользователи могут только читать на форуме</em>)</p>
</li>
<li>
<p>Диапазоны/отрезки без указания включительны ли окончания или нет ( например &ldquo;от 5 до 10&rdquo;)</p>
</li>
<li>
<p>Местоимения/замены (он, это, его, она) вызывающие двусмысленность ( например &ldquo;оповещение события должно показываться только когда оно обязательно&rdquo;)</p>
</li>
<li>
<p>Многозначность порядка союзов И/ИЛИ в предложении. Не все математики и не у всех приоритет И выше чем ИЛИ, поэтому проще писать односложными предложениями.</p>
</li>
<li>
<p>Тип vs Экземпляр (конкретный instance или класс в общем?)</p>
</li>
<li>
<p>IF без ELSE. Как правило вызывает внутренние недостатки в показе ошибок и тп.</p>
</li>
<li>
<p>Сравнение трёх или более человек</p>
</li>
<li>
<p>Незаконченные списки (и тд., тп., и др.), например при перечислении показываемых данных. Частая финансовая дыра для заказа дополнительных работ.</p>
</li>
</ol>
<p>Поля ввода данных в формах должна тоже в документации отражаться, но часто она недостаточна для программистов. Примитивная проверка в зависимости от типа может проверять..</p>
<ol>
<li>int - min, max, 0, float, точка или запятая, точность</li>
<li>date - format, будущее, прошлое, связь с другой датой для промежутков</li>
</ol>
<h3 id="уровни-тестов">Уровни тестов<a hidden class="anchor" aria-hidden="true" href="#уровни-тестов">#</a></h3>
<p>У тестов есть свои уровни, иерархия и классы (привет игроки RPG!). Проверять можно как разные части приложения (тоесть по площади, по страницам), так и разные свойства этого участка (тоесть в глубину, степени качества). Вот по размерам площадок можно тесты разбить на категории..</p>
<ul>
<li>Модульные (<em>unit-testing</em>). Полуавтоматическое тестирование, в том плане что тесты приходится писать программисту в очень тесном контакте с кодом классов которые unit-тест должен проверить. Не обязательно следовать TDD, можно написать хотя-бы для самых критичных частей (финансовые операции и тп.)</li>
<li>Интеграционные (<em>integration testing</em>) проверяют связи между разными модулями. Можно делать как до общей интеграции системы (модуль за модулем), так и после (пишем, пишем, сложим - протестим до финального <em>acceptance</em>-теста). Тут опять тесная работа с кодом и программистами.</li>
<li>Системные - пройтись по всей системе и найти несоответсвие общим стандартам и спецификации в целом. Как правило под конец, когда система в основном готова.</li>
<li><em>Acceptance</em>-тест проходит как правило уже с клиентом при передаче проекта и показывает готовность работы с клиентами. Именно на этой стадии появляются <em>альфа</em> версии (всё лежит ещё вероятно у разработчика на машине, привлекаются сторонние тестеры) и бета версии (всё уже лежит у клиента, привлекаются потенциальные клиенты)</li>
</ul>
<h3 id="типы-тестов">Типы тестов<a hidden class="anchor" aria-hidden="true" href="#типы-тестов">#</a></h3>
<p>Теперь собственно по сути тестирования..</p>
<ul>
<li>Функциональные отвечают на вопрос «<strong>что</strong>» должно делать приложение</li>
<li>Нефункциональные требования/тесты отвечают на вопрос «<strong>как</strong>». Нефункциональные включают в себя свойства удобства интерфейса, надёжности, безопасности данных, масштабируемости, кроссплатформенности и даже экономической целесообразности (см. ISO/IEC 9126)</li>
<li>Внешние (black box) / Внутренние (структурные, white box). Структурное тестирование проверяет внутреннюю структуру приложения как оно реализовано, но нуждается в понимании кода. Техники чёрного ящика исходит из того что ПО ещё не реализовано либо мы не знаем его точной работы, зато есть спецификация как должно всё работать. Структурные (<em>white box</em>) техники тестируют приложение снизу вверх, концентрируясь на максимальном покрытии кода (а не комбинаций входа-выхода в интерфейсе). Обычно white box техники используются в дополнение к чёрному ящику (как должно работать).</li>
<li>Регрессионное тестирование - а не поломалось ли что-то из-за этого изменения? Как правило именно это надо связывать с unit-тестированием для большей <a href="http://eagleson.livejournal.com/243485.html">автоматизации</a></li>
<li>Тест-поддержка (<em>maintenance testing</em>) - система уже работает и мы просто её обновляем (deploy &amp; migration). Миграции в последнее время тоже как правило автоматизируются.</li>
<li>Динамическое / статическое тестирование. Динамическое подразуемевает интерактив, работу с готовой системой или кодом. Это не всегда обязательно и возможно. Теоретически можно тестировать документацию или проверять логичность анализа, находить ошибки из логов и тп.</li>
</ul>
<p>Тестеры как и «писатели тех-задания» для самоконтроля всегда должны помнить аббревиатуру SMART, что-бы их правильно поняли более практичные люди.</p>
<ul>
<li>Specific - <strong>точное</strong> описание требования, без копи-пастов переписки с клиентом, чатом, дампом данных и односложными предложениями</li>
<li>Measureable - <strong>измеряемое</strong> значение чисел, времени, вероятности, пользователей, местоположения.</li>
<li>Attainable - <strong>технически-достижимые</strong> требования. Не всё ещё возможно технически, вперёд прогресса не угонишься</li>
<li>Realizeable - <strong>человечески-достижимые</strong> людские требования по времени, качеству, знанию, цене</li>
<li>Traceable - <strong>соответсвие</strong> изначальной идее и цели, логичность соответсвия нескольких требований.</li>
</ul>
<p><img loading="lazy" src="img/Pasted%20image%2020241020024046.png" alt=""  />
</p>
<h3 id="black-box-техники">Black box техники<a hidden class="anchor" aria-hidden="true" href="#black-box-техники">#</a></h3>
<p><strong>Ad-hoc</strong> (monkey) - случайное тестирование без определённой стратегии</p>
<p><strong>Исследовательское тестировани</strong>е (exploratory testing) - изучение продукта если документация во многом отсутствует</p>
<p>Группировка ошибок по <strong>эквивалентным классам</strong> (<em>equivalence partitioning</em>). Самая популярная методика. Берутся все входы и проверяются требования (по длине символов, возможных значениях). В тестах для минизации их количества классы разных входов комбинируются что-бы сделать максимальное покрытие ошибок.</p>
<p>Ещё одна техника существует преимущественно для целочисленных значений. Ошибки как правило возникают в <strong>пограничных значениях</strong>, поэтому методика так и называется (<em>boundary value analysis</em>). Выбираются два или три значения возле границы. Например если максимальная длина заголовка 250 символов, то как будет выдаваться ошибка при 249, 250 и 251 значении?</p>
<p>Более приближенная к динамическим системам есть методика проверки <strong>перехода состояний</strong> (<em>state transition testing</em>). Состояние зависит от входа и от предыдущего состояния. Состояния и переходы описываются графами (<em>finite state machine</em>).</p>
<p><strong>Таблица решений</strong> (decision table testing) сама собой приходит в голову когда бизнес-правила в приложении очень сложные и нуждаются в больших математических вычислениях. С помощью таблиц можно минимизировать число уникальных комбинаций</p>
<p><strong>Тестирование сценариев</strong> (use-case based) проходит согласно созданных в анализе сценариях, с учётом разных ролей, альтернативных потоков.</p>
<p><strong>Интуитивно-опытное тестирование</strong> (experience-based) как уже понятно приходит у человека со временем и позволяет находить систематические ошибки дизайна, программистов, потока данных с учётом изменения кода.</p>
<h3 id="white-box-структурные-техники">White box (структурные) техники<a hidden class="anchor" aria-hidden="true" href="#white-box-структурные-техники">#</a></h3>
<p>Цель структурных техник - максимально покрыть тестами код (<em>code coverage</em>), а поскольку white box используется как дополнение к сценарным техникам, то логично, что есть и максимальное покрытие сценариев или, точнее, их разветвлений (statement &amp; decision coverage).</p>
<p>Математически процент покрытия = 100% * число <strong>покрытых единиц</strong> / число всех единиц. Это не значит, что будет всё протестировано, только выбранные единицы тестирования (<em>coverage item</em>). Единицы тестирования для каждой роли по разному выглядят - для разработчиков это таблицы БД, функции в коде, запрос к внешнему компоненту, тогда как для тестера и аналитика это действия в сценарии, классы эквивалентности.</p>
<p>Поднимаясь выше над единицами тестирования можно увидеть <strong>предложения</strong> и соответственно покрывать их (<em>statement coverage</em>). Хорошее тестирование с методиками чёрного ящика могут покрыть до 60-75% предложений. В плане кода это конкретная строка</p>
<p>Покрытие <strong>разветвлений</strong> (<em>decision coverage</em>) уже более высокий уровень, включает все типы иерархии (if-else, switch, вызовы методов и тп.). Методами чёрного ящика можно покрыть 40-60%. <strong>Циклическая сложность</strong> (cyclomatic complexity) - проверка алгоритма известная всем информатикам на квадратичную, экспоненциальную и логарифмическую сложность.</p>
<p>Следующая степень покрытия включает возможные <strong>пути</strong> по которым в принципе можно пройти по равзветвлениям. Теоретически этих путей бесконечно много если учитывать все циклы.</p>
<h3 id="составляющие-бага">Составляющие бага<a hidden class="anchor" aria-hidden="true" href="#составляющие-бага">#</a></h3>
<p>Самая большая проблема как я уже наверху писал - неточное описание бага. Программисты тратят много времени на то что-бы понять где и что происходит неправильно и как оно должно работать. Правильный баг-report включает в себя:</p>
<ul>
<li><em>Уникальный ID</em> по которому можно на него ссылаться</li>
<li><em>Ссылка на требование</em> которое не выполнено (ID или пункт в .doc файле)</li>
<li>Цель требования вкратце</li>
<li>Предшествующие обстоятельства (местоположение, пользователь, группа)</li>
<li>Вход (действия пользователя)</li>
<li>Выход (существующая реакция системы)</li>
<li>Ожидаемый выход (согласно требованию)</li>
<li>Дополнительные требования (бонус?)</li>
<li>Дополнительные связи</li>
</ul>
<h3 id="инструменты">Инструменты<a hidden class="anchor" aria-hidden="true" href="#инструменты">#</a></h3>
<p>Наиболее знакомые инструменты программистом это конечно системы отслеживания ошибок (bug/issue tracking) - <a href="http://www.mantisbt.org/">Mantis</a>, <a href="http://www.bugzilla.org/">Bugzilla</a>, <a href="http://www.atlassian.com/software/jira/">Jira</a> и <a href="http://trac.edgewall.org/">Trac</a>. Некоторые IDE могут интегрироваться с ними так, что commit-действии в репозиторий версионной системы (SVN/CVS/Git/Mercurial) можно обновить баг без работы в браузере.</p>
<p>Есть и более общие, индустриальные продукты включающие в себя и составление требований, группировку сценариев - <a href="https://h10078.www1.hp.com/cda/hpms/display/main/hpms_content.jsp?zn=bto&cp=1-11-127-24_4000_100__">HP (Mercury) Quality Center</a> и <a href="http://www-01.ibm.com/software/awdtools/rqm/standard/">IBM Rational Quality Manager</a> Автоматизированное тестирование интерфейсов сейчас наиболее популярно с помощью <a href="http://seleniumhq.org/">Selenium</a>, <a href="http://www.borland.com/us/products/silk/silktest/index.html">SilkTest</a>, <a href="https://h10078.www1.hp.com/cda/hpms/display/main/hpms_content.jsp?zn=bto&cp=1-11-127-24%5E1352_4000_100__">HP QuickTest Pro</a>, QF-Test, <a href="http://www-01.ibm.com/software/awdtools/tester/robot/index.html">Rational Robot</a>, <a href="http://www.automatedqa.com/products/testcomplete/">TestComplete</a>, <a href="http://watir.com/">Watir</a>, TestPartner, <a href="http://cubictest.seleniumhq.org/">CubicTest</a>, <a href="http://www.getwindmill.com/">Windmill</a>. Есть и более экзотические тесты типа <a href="http://www.soapui.org/">soapUI</a></p>
<p>Нагрузочное тестирование чуть более сложное, потому что нужны дополнительные машины (скажем одна машина симулирует 300 пользователей-соединений) - на одной машине запускать 3000 соединений как правило невозможно. Инструменты:</p>
<ul>
<li>Мелкие - Apache ab, <a href="http://httperf.comlore.com/">httpperf</a>, <a href="http://freshmeat.net/projects/openload/">openload</a>, <a href="http://www.neotys.com/evaluation/overviewEval.html">Neoload</a>, <a href="http://hammerora.sourceforge.net/">hammerora</a>, <a href="http://dklab.ru/lib/dklab_multiplexor/">dklab multiplexor</a></li>
<li>Большие - Apache <a href="http://jakarta.apache.org/jmeter/">JMeter</a>, <a href="http://www-01.ibm.com/software/awdtools/tester/performance/index.html">IBM Rational Performance Tester</a>, <a href="https://h10078.www1.hp.com/cda/hpms/display/main/hpms_content.jsp?zn=bto&cp=1-11-15-17%5E8_4000_100__">HP LoadRunner</a> (Mercury), <a href="http://www.oracle.com/enterprise_manager/application-quality-solutions.html">Oracle Application Quality Management</a> (Empirix e-Load)</li>
</ul>
<p><img loading="lazy" src="img/Quick&#43;Test&#43;Performance.gif" alt=""  />
</p>
<p><img loading="lazy" src="img/SilkTest&#43;Recorder.jpg" alt=""  />
</p>
<p><img loading="lazy" src="img/reporting_execution_trend.png" alt=""  />
</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2024 <a href="http://localhost:1313/">Artjom Kurapov blog</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
