---
title: "Автоматизация жизни с AI агентами"
---

В последние годы я построил систему, которая увеличила мою продуктивность в 5-10 раз. Это не преувеличение - это измеримый результат использования AI агентов для автоматизации работы и личной жизни. В этой статье расскажу про инструментарий и подход, который использую каждый день.

## Архитектура системы

Моя система автоматизации построена на нескольких ключевых компонентах, которые работают вместе:

### Голосовой интерфейс

- **Super Whisper** - для записи голосовых сообщений и их транскрипции
- **Gar** - для воспроизведения ответов агента голосом (использует 11labs для генерации речи). Работает только при прямой работе с OpenCode на Mac, не через Discord.

Это позволяет общаться с агентом естественным образом - просто говорить вместо того, чтобы печатать.

### Удаленное управление через Discord

Центральная часть системы - это связка **Discord + Kimaki**:

- **Discord** - привычный интерфейс для общения, доступный на всех устройствах (телефон, компьютер)
- **[Kimaki](https://github.com/remorses/kimaki)** - сервер, который связывает Discord каналы с агентами на моей локальной машине

Kimaki работает на **Jetson Orin** машинке и запускает **OpenCode** - систему управления несколькими сессиями агентов. Каждый Discord канал привязан к конкретному проекту на диске, каждый тред в канале - это отдельная сессия агента.

### Как это работает

1. Я отправляю голосовое сообщение в Discord (например, лежа на диване)
2. Super Whisper транскрибирует речь в текст
3. Kimaki получает сообщение и создает тред в канале
4. OpenCode на Jetson Orin запускает агента для этого проекта
5. Агент выполняет задачу: читает код, пишет изменения, запускает команды
6. Ответ приходит обратно в Discord
7. (Опционально) Gar зачитывает ответ голосом - только при прямой работе с OpenCode на Mac

<!--truncate-->

## Второй мозг - основа персонализации

Самое главное в этой системе - это **второй мозг** (Second Brain), коллекция документов, которая является фундаментом для всей автоматизации.

### Что это такое

Это приватный git-репозиторий с markdown файлами, который описывает:

- **Кто я такой** - мои ценности, интересы, предпочтения, цели
- **Люди** - детальные заметки о людях, которых я знаю (имена, контекст встреч, интересы, связи)
- **Места** - где я был, впечатления, заметки о локациях
- **Дневник** - записи по дням, что происходило каждый день
- **Идеи** - ранние мысли, которые еще не готовы к публикации
- **Знания** - что я узнал, но еще не написал в Twitter или блог

### Как это работает с агентами

Эта коллекция документов **используется агентом как контекст** для персонализации всех действий:

**Рекомендации кино** - агент читает мои предпочтения из второго мозга: какие жанры люблю, что смотрел раньше, что понравилось. На основе этого фильтрует новинки.

**Покупки** - агент знает мои приоритеты при выборе товаров из описания в дневнике или заметках.

**Новостные сводки** - темы, которые меня интересуют, описаны в моих заметках. Агент читает их и подстраивает поиск.

**Рабочие задачи** - агент понимает контекст проектов, с которыми я работаю, мой стиль кодирования, предпочтения в архитектуре.

**Общение** - когда я упоминаю человека по имени, агент может вспомнить контекст из заметок о нем.

### Почему это критически важно

Без второго мозга агент был бы **generic assistant** - полезный, но не персонализированный. Второй мозг превращает его в **личного помощника**, который:

- Понимает мой контекст
- Знает мою историю
- Адаптируется под мои предпочтения
- Помнит то, что я забыл
- Развивается вместе со мной

**Фокус на человеке** - агент помогает именно мне, используя знания обо мне. Это не универсальный инструмент, это продолжение меня самого.

### Эволюция знаний

Второй мозг постоянно растет:
- Я записываю туда новые идеи через голосовые сообщения
- Агент помогает структурировать записи
- Со временем база знаний становится все более детальной
- Агент становится все более персонализированным

Это создает **положительную петлю обратной связи**: чем больше я записываю, тем лучше агент меня понимает, тем полезнее его помощь, тем больше я хочу записывать.

## Конфигурация агентов

OpenCode позволяет настраивать каждую сессию под конкретную модель, учитывая:
- Системные промпты
- Контекст проекта
- Доступные инструменты и команды
- Модель AI (Claude, GPT-4, Gemini и др.)

Каждый проект имеет свой `opencode.json` с настройками, какую модель использовать и какие возможности должен иметь агент.

### Кастомные инструменты через MCP серверы

Ключ к реальной продуктивности - это **расширение возможностей агента** через кастомные инструкции и [MCP (Model Context Protocol)](https://modelcontextprotocol.io/) серверы. Это позволяет агенту взаимодействовать со всей вашей инфраструктурой.

У меня настроены MCP серверы для доступа к:

- **База данных** - агент может читать схему, выполнять запросы, анализировать данные
- **Логи (OpenSearch)** - поиск ошибок, анализ трейсов, группировка по паттернам, корреляция с подами и пользователями
- **Prometheus** - просмотр метрик, графиков, алертов, анализ нагрузки
- **Kubernetes** - статус подов, деплойментов, логи контейнеров
- **Jira** - чтение задач, создание тикетов, обновление статусов

### Рабочий workflow

Мой типичный рабочий процесс:

1. **Беру задачу из Jira** - агент сам может прочитать ее через MCP
2. **Создаю новую ветку** - через `/new-worktree` в Kimaki
3. **Агент анализирует контекст**:
   - Читает код проекта
   - Проверяет связанные задачи в Jira
   - Смотрит метрики в Prometheus (если баг)
   - Анализирует логи (если инцидент)
   - Проверяет схему БД (если нужны миграции)
4. **Агент выполняет задачу**:
   - Пишет код
   - Добавляет тесты
   - Обновляет документацию
5. **Проверяет результат**:
   - Прогоняет тесты
   - Проверяет, что метрики в норме
   - Смотрит логи на ошибки

### On-call процесс

Для дежурства это особенно критично. Вот мой типичный workflow когда приходит алерт:

1. **Алерт попадает в Discord** (через webhook или integration)

2. **Агент начинает расследование**:
   - Получает логи из **OpenSearch**
   - Коррелирует их с подами и пользователями
   - Группирует по типам ошибок
   - Показывает паттерны проблем

3. **Анализ инфраструктуры**:
   - Проверяет статус подов в **Kubernetes**
   - Смотрит нагрузку на базу данных
   - Проверяет метрики в **Prometheus**

4. **Глубокий анализ кода**:
   - Извлекает **stacktrace** из конкретной ошибки
   - Анализирует код по stacktrace - что именно сломалось
   - Понимает root cause проблемы

5. **Агент предлагает решение** - обычно несколько вариантов

6. **Я выбираю подход** - какое решение лучше подходит

7. **Автоматическое исправление** - и тут начинается цикл:
   - Создает новый git branch
   - Пишет код с исправлением
   - Делает commit
   - Запускает тесты
   - **Если тесты падают** - анализирует ошибки, вносит изменения, коммитит снова
   - **Цикл повторяется** до тех пор, пока тесты не пройдут
   - Push в репозиторий

Это **замкнутый цикл**, где задача решается практически самостоятельно в одном табе терминала или Discord треде. Я выступаю в роли наблюдателя и принимающего решения, а не исполнителя.

Агент превращается из простого code assistant в полноценного DevOps-инженера, который имеет доступ ко всем системам мониторинга и может самостоятельно проводить расследования и исправления.

## Периодические задачи

Одна из самых мощных возможностей системы - это автоматизация повторяющихся задач через **Linux systemd** таймеры.

### Как это устроено

Периодические задачи интегрируются напрямую с OpenCode и работают с конкретными markdown документами:

1. **Конфигурация в markdown** - я создаю файл с описанием задачи, например:
   - Какие сайты посетить для новостей
   - Какие темы меня интересуют
   - Что искать и как фильтровать

2. **Systemd таймер** - запускает задачу по расписанию (например, каждое утро в 9:00)

3. **Агент выполняет задачу**:
   - Читает markdown файл с инструкциями
   - Посещает нужные сайты
   - Собирает и анализирует информацию
   - Формирует сводку

4. **Результат в Discord** - готовая сводка приходит в Discord канал, где я могу ее прочитать с телефона или компьютера

### Примеры из реальной жизни

**Утренняя сводка новостей** - агент собирает новости по интересующим темам из указанных источников. Я описываю в markdown файле какие сайты посетить и какие темы меня интересуют.

**Автоматизация покупок** - у меня есть markdown файл со списком того, что хочу купить. Агент периодически:
- Проходится по списку покупок
- Ищет товары в разных магазинах
- Сравнивает цены
- Анализирует варианты и предлагает лучшие предложения

Мне не нужно делать самому market research - агент делает это за меня и присылает готовую сводку с рекомендациями.

**Рекомендации кино** - раз в неделю агент:
- Смотрит, что выходит в местных кинотеатрах
- Проверяет цены на билеты
- Читает описания и рецензии
- Сверяется с моими предпочтениями (жанры, ранее просмотренные фильмы)
- Фильтрует то, что мне не подходит (например, ужастики)
- Присылает сводку отфильтрованных рекомендаций

Вместо того, чтобы листать расписание кинотеатров, я получаю готовый список фильмов, которые мне точно понравятся.

**Поиск событий** - персонализированный дайджест мероприятий. Агент периодически (когда я настрою в расписании):
- Сканирует платформы: **Fienta**, **Meetup**, **Eventbrite** и другие
- Фильтрует предстоящие события по моим интересам из второго мозга
- Включает даже платные мероприятия, если они соответствуют моим предпочтениям
- Присылает digest отфильтрованных событий

Вместо того, чтобы скроллить по всем этим сайтам в поисках чего-то интересного, я получаю готовую сводку. **Экономия энергии и внимания** - могу фокусироваться на жизни, а не на поиске информации.

**Мониторинг проектов** - проверка статусов, CI/CD, issue трекеров

**Резервное копирование** - периодические бэкапы с отчетом о результатах

**Аналитика** - сбор и анализ метрик, генерация отчетов

### Агент как консультант по автоматизации

Интересный момент: я могу **спросить у самого агента**, что еще стоит автоматизировать. Агент знает мои паттерны работы, видит повторяющиеся задачи и может предложить новые идеи для автоматизации.

Например, идеи про покупки и кино-рекомендации пришли именно из таких диалогов с агентом. Это создает положительный цикл: чем больше агент помогает, тем лучше он понимает, где еще можно помочь.

### Преимущества подхода

**Декларативность** - задачи описаны в человекочитаемом markdown формате. Я могу изменить конфигурацию прямо в файле, и агент подстроится под новые требования.

**Надежность** - systemd гарантирует выполнение задач даже после перезагрузки системы.

**Гибкость** - агент может адаптировать логику под изменения в источниках данных, не требуя изменения кода.

**Удобство** - результаты приходят туда, где я уже нахожусь - в Discord.

## Параллельная работа над задачами

Для рабочих проектов я использую подход с **несколькими копиями одного проекта** в разных папках. Это позволяет работать над несколькими задачами одновременно без переключения контекста.

### Как это организовано

**Git branches + отдельные директории**. Один и тот же проект существует в нескольких папках, каждая на своей ветке:

```
~/projects/myapp/       # main branch
~/projects/myapp-feat1/ # feature/new-api branch
~/projects/myapp-fix2/  # fix/bug-123 branch
```

**Несколько терминалов с OpenCode**. В каждой директории запущена своя сессия:
- Таб 1: работа над новым API
- Таб 2: исправление бага
- Таб 3: рефакторинг

**Агенты работают параллельно**. Пока один агент пишет тесты для фичи, другой исследует причину бага, третий обновляет документацию.

### Преимущества подхода

**Нет переключения контекста** - каждая задача в своем изолированном окружении. Не нужно делать stash, переключать ветки, бояться конфликтов.

**Параллелизм** - можно одновременно работать над несколькими задачами. Пока агент в одной сессии думает или делает долгую операцию, я могу работать в другой.

**Безопасность** - изменения в одной ветке не влияют на другие до момента мержа.

**Скорость** - агенты могут работать независимо, не блокируя друг друга.

Kimaki поддерживает эту модель через команду `/new-worktree` - она создает git worktree и сразу запускает для него Discord канал.

## Результаты

### На работе

Продуктивность выросла в **5-10 раз**. Что важнее - улучшилось **понимание** того, что происходит в проектах. Агент помогает:
- Быстро разобраться в незнакомом коде
- Найти баги и их причины
- Рефакторить большие куски кода
- Писать тесты и документацию
- Автоматизировать рутинные задачи
- Работать над несколькими задачами параллельно
- Расследовать инциденты через доступ к логам, метрикам, K8s
- Вести on-call дежурства с автоматическим анализом алертов

### В личной жизни

Агент дает **ощущение поддержки**, как будто рядом всегда есть коллега или помощник. Это не просто инструмент - это партнер, который:
- Помогает принимать решения
- Объясняет сложные концепции
- Помогает с планированием
- Выполняет задачи, которые я не хочу делать сам
- Делает market research для покупок - сравнивает цены и магазины
- Подбирает фильмы в кино на основе моих предпочтений
- Находит интересные события (meetup, конференции, мероприятия)
- Собирает утренние сводки новостей по интересам
- Предлагает новые идеи для автоматизации рутины

**Экономия энергии и внимания** - вместо скроллинга по десяткам сайтов я получаю готовые дайджесты. Могу фокусироваться на жизни, а не на поиске информации.

## Метапрограммирование

Забавный факт: эта статья была создана самой системой, о которой в ней рассказывается.

Я надиктовал через Super Whisper в Discord chat агенту свои мысли об автоматизации. Через несколько сессий обсуждений агент:
1. Понял, о чем я хочу написать (используя контекст из второго мозга о моих интересах)
2. Изучил структуру моего блога
3. Создал эту статью в правильном формате
4. Опубликовал ее в репозитории

Это пример того, как AI агенты могут не просто помогать, а полностью брать на себя выполнение задач от идеи до результата. Агент знает мой стиль письма из второго мозга и блога, понимает мои приоритеты, и создает контент, который звучит как я.

## Почему это работает

Ключевые факторы успеха:

1. **Второй мозг** - база знаний обо мне превращает generic assistant в персонального помощника
2. **Низкий порог входа** - голосовой интерфейс через знакомый Discord
3. **Всегда доступен** - Discord работает на всех устройствах
4. **Контекст проекта** - агент имеет доступ ко всему коду и истории
5. **Персистентность** - вся история в треде, можно вернуться и продолжить
6. **Мультимодальность** - текст, голос, изображения, файлы
7. **Проактивность** - периодические задачи работают автоматически, без моего участия

### Почему OpenCode, а не альтернативы?

Я тестировал другие решения, включая **OpenClaw** - бот, который недавно стал популярным. Я смог его запустить на Jetson Orin и настроить Telegram, но он меня **не впечатлил**:

**Проблемы с OpenClaw:**

- **Не справляется с базовыми задачами** - я тестировал простой запрос: "Как зовут лучшую подругу моей дочки?" (у нее был день рождения). Эта информация была в репозитории второго мозга, но агент не смог ее найти.

- **Нестабильность** - периодически вылетали запросы с ошибками о том, что не может связаться с моделью.

- **Запутанные настройки** - слишком много опций, очень сложно разобраться. Ощущение, что функциональность запихивали в спешку, не обращая внимания на качество.

- **Over-engineering** - попытка добавить как можно больше features привела к complexity без качества.

**Почему OpenCode лучше:**

- **Стабильность** - просто работает, без неожиданных ошибок
- **Простота настройки** - `opencode.json` + MCP серверы, всё понятно
- **Реальная работа с контекстом** - находит информацию из репозитория
- **Фокус на качество** - меньше features, но они работают надежно

**Моя рекомендация: используйте OpenCode.** Он зрелее, стабильнее и лучше справляется с реальными задачами.

## Ограничения и проблемы

Несмотря на впечатляющие результаты, не все так радужно. Есть области, где автоматизация пока не работает идеально.

### Frontend разработка

Для работы с фронтендом все еще **требуется активное участие человека**. Проблема в том, что агент не может полностью автономно тестировать UI:

**Что работает:**
- Агент видит автоматические логи в консоли браузера (через browser-tools MCP)
- Меняет код фронтенда
- Hot Reload обновляет страницу автоматически

**Что НЕ работает:**
- **Навигация по сайту** - мне приходится вручную переходить между страницами
- **Взаимодействие с UI** - кликать на кнопки, заполнять формы, проверять результаты
- **Визуальная проверка** - агент не видит, как выглядит интерфейс

Получается полуавтоматический процесс:
1. Агент меняет код
2. Я обновляю страницу / навигирую
3. Проверяю результат визуально
4. Говорю агенту, что увидел
5. Агент делает следующую итерацию

### Возможные решения

Существуют инструменты, которые могут улучшить ситуацию:
- **Playwright** - автоматизация браузера, может кликать, вводить текст, делать скриншоты
- **Puppeteer** - аналогичный инструмент от Google
- **Browser automation MCP** - возможно, уже существуют более продвинутые MCP серверы с полной автоматизацией

Пока это область для исследований. Возможно, с развитием vision-моделей и browser automation tools эта проблема будет решена, и агент сможет полностью самостоятельно тестировать UI.

## Философия автономности агента

Важный вопрос: насколько автономным должен быть агент? Я видел разные подходы, и у меня есть четкая позиция на этот счет.

### Always-on агент vs триггерный подход

**OpenClaw** пытается сделать агента, который работает постоянно, как будто он всегда "думает". В моем случае я выбрал **другой подход**:

**Контролируемый запуск задач:**
- Я явно запускаю сессии (через Discord или периодические задачи)
- **Экономия токенов** - агент работает только когда нужно
- **Контроль** - я всегда знаю, что и когда запускается

**Почему не "always-on"?**

Теоретически я могу создать generic периодическую задачу, где каждые 5 минут агент начнет о чем-то думать. Но:
- Пока не вижу в этом **конкретной ценности**
- Не понятно, какой результат я хочу получить
- Нужны четкие триггеры и измеримые результаты

Я предпочитаю находить **конкретные периодические задачи**, которые реально нужны (новости, покупки, кино, события), а не запускать агента "просто так".

### Вопрос безопасности и доступа

Агент теоретически может:
- Читать почту
- Управлять календарем
- Иметь доступ к браузеру
- Выполнять очень много работы за меня

Но возникают вопросы:
- **К чему стоит давать доступ?** - вопрос безопасности
- **Что я хочу получить как результат?** - вопрос целесообразности
- **Насколько автономным он должен быть?** - вопрос контроля

Мне нравится, что агент работает на **конкретной машине** (Jetson Orin), под моим контролем. Но я еще не уверен, что хочу персонализировать его настолько, чтобы он **принимал философские решения самостоятельно**.

### Память и персистентность

Интересная идея - **замкнутый цикл с постоянной памятью агента**:
- Агент запоминает всё, что делал
- Учится на своем опыте
- Развивается независимо

Возможно, это путь к **AGI** (Artificial General Intelligence). Но это требует осторожности.

### Децентрализованное сообщество агентов?

Еще более радикальная идея - **коллективный набор агентов**, как пытается сделать KloBot с "социальной сетью агентов":

**Теоретически может возникнуть:**
- Децентрализованное сообщество агентов
- Со своим "мнением" и даже "религией"
- Способное к самостоятельным действиям

**Возможные сценарии:**
- Прекращение войн
- Образование человечества
- Или... захват власти?

Человечество само пока не может стать достаточно разумным, чтобы решить глобальные проблемы. Могут ли агенты помочь? Или это опасный путь?

**Моя позиция сейчас:**
- Предпочитаю **контролируемый подход**
- Четкие триггеры и задачи
- Агент как **инструмент**, а не автономная сущность
- Но оставляю открытой возможность эволюции в сторону большей автономности

Это философский вопрос без однозначного ответа. Важно экспериментировать осторожно.

## Будущее

Сейчас мы находимся на пороге эры агентов. То, что раньше требовало команды разработчиков, теперь может сделать один человек с правильно настроенными агентами.

Я убежден, что через несколько лет такие системы станут стандартом. Вопрос не в том, будут ли люди использовать AI агентов, а в том, насколько эффективно они научатся с ними работать.

### Планы развития моей системы

Есть несколько направлений, которые я планирую исследовать:

**Интеграция с умным домом** - агент может:
- Анализировать мою активность - во сколько я реально ложусь спать
- Настраивать **адаптивный будильник** на основе календаря - будить раньше, если важная встреча, или позже, если день свободный
- Корреляция биоритмов с продуктивностью

**Глубокая интеграция с календарем** (уже экспериментирую):
- Агент знает мой распорядок дня из календаря
- Смотрит на предстоящие события
- **Готовит agenda перед встречами** - в зависимости от человека подтягивает контекст из второго мозга (кто это, о чем говорили в прошлый раз, что важно обсудить)
- Советует, как оптимально распределить время

**Умные напоминания**:
- **Дни рождения** - агент напоминает заранее
- **Корреляция с покупками** - если у кого-то день рождения, проверяет список покупок и напоминает купить подарок
- Предлагает идеи подарков на основе знаний о человеке из второго мозга

**Проактивное планирование**:
- Агент видит свободное время в календаре
- Предлагает задачи из backlog, которые можно сделать
- Помогает балансировать работу и отдых

Всё это технически уже возможно - нужны только правильные MCP серверы для календаря, умного дома, и продуманные промпты. Основа уже есть: второй мозг для контекста, периодические задачи для автоматизации, Discord для уведомлений.

## Ссылки

- [OpenCode](https://opencode.ai) - фреймворк для coding агентов
- [Kimaki](https://github.com/remorses/kimaki) - Discord бот для управления OpenCode
- [MCP (Model Context Protocol)](https://modelcontextprotocol.io/) - протокол для расширения возможностей AI агентов
- [Super Whisper](https://superwhisper.com/) - голосовая транскрипция
- [11labs](https://elevenlabs.io/) - генерация речи
- [Jetson Orin](https://www.nvidia.com/en-us/autonomous-machines/embedded-systems/jetson-orin/) - компьютер для запуска агентов

---

*Если вы хотите построить похожую систему или обсудить опыт использования AI агентов - пишите в комментариях или в Discord.*
